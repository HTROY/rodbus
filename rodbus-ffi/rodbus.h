#ifndef RODBUS_FFI_H
#define RODBUS_FFI_H

/* Generated with cbindgen:0.14.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "prelude.h"

/**
 * Maximum count allowed in a read coils/discrete inputs request
 */
#define MAX_READ_COILS_COUNT 2000

/**
 * Maximum count allowed in a read holding/input registers request
 */
#define MAX_READ_REGISTERS_COUNT 125

/**
 * Maximum count allowed in a `write multiple coils` request
 */
#define MAX_WRITE_COILS_COUNT 1968

/**
 * Maximum count allowed in a `write multiple registers` request
 */
#define MAX_WRITE_REGISTERS_COUNT 123

/**
 * Exception values from the Modbus specification
 */
enum Exception {
  /**
   * The function code received in the query is not an allowable action for the server
   */
  EXCEPTION_ILLEGAL_FUNCTION = 1,
  /**
   * The data address received in the query is not an allowable address for the server
   */
  EXCEPTION_ILLEGAL_DATA_ADDRESS = 2,
  /**
   * A value contained in the request is not an allowable value for server
   */
  EXCEPTION_ILLEGAL_DATA_VALUE = 3,
  /**
   * An unrecoverable error occurred while the server was attempting to perform the requested
   * action
   */
  EXCEPTION_SERVER_DEVICE_FAILURE = 4,
  /**
   * Specialized use in conjunction with  programming commands
   * The server has accepted the request and is processing it
   */
  EXCEPTION_ACKNOWLEDGE = 5,
  /**
   * Specialized use in conjunction with  programming commands
   * The server is engaged in processing a long-duration program command, try again later
   */
  EXCEPTION_SERVER_DEVICE_BUSY = 6,
  /**
   * Specialized use in conjunction with function codes 20 and 21 and reference type 6, to
   * indicate that the extended file area failed to pass a consistency check.
   * The server attempted to read a record file, but detected a parity error in the memory
   */
  EXCEPTION_MEMORY_PARITY_ERROR = 8,
  /**
   * Specialized use in conjunction with gateways, indicates that the gateway was unable to
   * allocate an internal communication path from the input port to the output port for
   * processing the request. Usually means that the gateway is mis-configured or overloaded
   */
  EXCEPTION_GATEWAY_PATH_UNAVAILABLE = 10,
  /**
   * Specialized use in conjunction with gateways, indicates that no response was obtained
   * from the target device. Usually means that the device is not present on the network.
   */
  EXCEPTION_GATEWAY_TARGET_DEVICE_FAILED_TO_RESPOND = 11,
};
typedef uint8_t Exception;

/**
 * Levels of logging
 */
enum Level {
  LEVEL_ERROR,
  LEVEL_WARN,
  LEVEL_INFO,
  LEVEL_DEBUG,
  LEVEL_TRACE,
};
typedef uint8_t Level;

/**
 * Status returned during synchronous and asynchronous API calls
 */
enum Status {
  /**
   * The operation was successful and any return value may be used
   */
  STATUS_OK,
  /**
   * The channel was shutdown before the operation could complete
   */
  STATUS_SHUTDOWN,
  /**
   * No connection could be made to the server
   */
  STATUS_NO_CONNECTION,
  /**
   * No valid response was received before the timeout
   */
  STATUS_RESPONSE_TIMEOUT,
  /**
   * The request was invalid
   */
  STATUS_BAD_REQUEST,
  /**
   * The response was improperly formatted
   */
  STATUS_BAD_RESPONSE,
  /**
   * An I/O error occurred on the underlying stream while performing the request
   */
  STATUS_IO_ERROR,
  /**
   * A framing error was detected while performing the request
   */
  STATUS_BAD_FRAMING,
  /**
   * The server returned an exception code (see separate exception value)
   */
  STATUS_EXCEPTION,
  /**
   * An unspecified internal error occurred while performing the request
   */
  STATUS_INTERNAL_ERROR,
};
typedef uint8_t Status;

typedef struct BitIterator BitIterator;

typedef struct Handler Handler;

typedef struct RegisterIterator RegisterIterator;

typedef struct ServerHandle ServerHandle;

typedef struct Updater Updater;

/**
 * @brief Struct that bundles together the types needed to make requests on a channel
 */
typedef struct Session {
  /**
   * #Runtime on which requests will be run
   */
  Runtime *runtime;
  /**
   * #Channel to which requests will be sent for processing
   */
  Channel *channel;
  /**
   * Modbus unit identifier to use in requests and expect in responses
   */
  uint8_t unit_id;
  /**
   * Response timeout in milliseconds
   */
  uint32_t timeout_ms;
} Session;

typedef bool (*WriteSingleCallback_bool)(bool, uint16_t, void*);

typedef bool (*WriteSingleCallback_u16)(uint16_t, uint16_t, void*);

typedef bool (*WriteMultipleCallback_bool)(const bool*, uint16_t, uint16_t, void*);

typedef bool (*WriteMultipleCallback_u16)(const uint16_t*, uint16_t, uint16_t, void*);

typedef struct Callbacks {
  WriteSingleCallback_bool write_single_coil_cb;
  WriteSingleCallback_u16 write_single_register_cb;
  WriteMultipleCallback_bool write_multiple_coils;
  WriteMultipleCallback_u16 write_multiple_registers;
} Callbacks;

typedef struct Sizes {
  uint16_t num_coils;
  uint16_t num_discrete_inputs;
  uint16_t num_holding_registers;
  uint16_t num_input_registers;
} Sizes;

/**
 * @brief Optional non-default configuration of the Tokio runtime
 */
typedef struct RuntimeConfig {
  /**
   * Core number of worker threads for the Runtime's thread pool
   * Default is the number of cores on the system
   */
  uint16_t num_core_threads;
} RuntimeConfig;

/**
 * @brief Type that describes the success or failure of an operation
 */
typedef struct Result {
  /**
   * describes the success (ok) or failure of an operation
   */
  Status status;
  /**
   * when status == Status_Exception, this value provides
   * the Modbus exception code returned by the server
   */
  uint8_t exception;
} Result;

Updater *acquire_updater(Handler *handler);

/**
 * @brief Convenience function to build a session struct
 *
 * This function does not allocate and is merely a helper function create the #Session struct.
 *
 * @param runtime       pointer to the #Runtime that will be used to make requests on the channel
 * @param channel       pointer to the #Channel on which requests associated with the built #Session will be made
 * @param unit_id       Modbus unit identifier of the server
 * @param timeout_ms    timeout in milliseconds for any requests made via this session object
 * @return              built Session struct ready for use with the Modbus request functions
 */
Session build_session(Runtime *runtime,
                      Channel *channel,
                      uint8_t unit_id,
                      uint32_t timeout_ms);

Callbacks create_callbacks(WriteSingleCallback_bool write_single_coil_cb,
                           WriteSingleCallback_u16 write_single_register_cb,
                           WriteMultipleCallback_bool write_multiple_coils,
                           WriteMultipleCallback_u16 write_multiple_registers);

Handler *create_handler(Runtime *runtime, Sizes sizes, Callbacks callbacks, void *user_data);

ServerHandle *create_server(Runtime *runtime,
                            const char *address,
                            uint8_t unit_id,
                            Handler *handler);

Sizes create_sizes(uint16_t num_coils,
                   uint16_t num_discrete_inputs,
                   uint16_t num_holding_registers,
                   uint16_t num_input_registers);

/**
 * @brief Create an instance of a TCP client channel
 *
 * This function allocates an opaque struct which must be later destroyed using destroy_channel()
 *
 * @param runtime                    pointer to the #Runtime that will be used to run the channel task
 * @param address                    string representation on an IPv4 or IPv6 address and port, e.g. "127.0.0.1:502"
 * @param max_queued_requests        Maximum number of queued requests that will be accepted before back-pressure (blocking) is applied
 * @return                           pointer to the channel or NULL if the address parameter cannot be parsed
 *
 * @warning destroying the underlying runtime does NOT automatically destroy a #Channel on the runtime
 * and destroy_channel() must always be used to free the memory
 */
Channel *create_tcp_client(Runtime *runtime,
                           const char *address,
                           uint16_t max_queued_requests);

/**
 * @brief create an instance of the multi-threaded work-stealing Tokio runtime
 *
 * This instance is typically created at the beginning of your program and destroyed
 * using destroy_runtime() before your program exits.
 *
 * @param config Optional configuration of the runtime. If "config" is NULL, default
 * settings are applied
 *
 * @return An instance of the runtime or NULL if it cannot be created for some reason
 */
Runtime *create_threaded_runtime(const RuntimeConfig *config);

/**
 * @brief Destroy a previously created channel instance
 *
 * This operation stops channel task execution. Any pending asynchronous callbacks
 * may not complete, and no further Modbus requests on this channel should be made
 * after this call.
 *
 * @param channel #Channel to stop and destroy
 *
 * @note This function checks for NULL and is a NOP in this case
 */
void destroy_channel(Channel *channel);

void destroy_handler(Handler *handler);

/**
 * @brief Destroy a previously created runtime instance
 *
 * This operation is typically performed just before program exit. It blocks until
 * the runtime stops and all operations are canceled. Any pending asynchronous callbacks
 * may not complete, and no further Modbus requests can be made after this call using this
 * runtime and any channels or sessions created from it
 *
 * @param runtime #Runtime to stop and destroy
 *
 * @note This function checks for NULL and is a NOP in this case
 */
void destroy_runtime(Runtime *runtime);

void destroy_server(ServerHandle *handle);

bool get_next_bit(BitIterator *iterator, bool *value, uint16_t *index);

bool get_next_register(RegisterIterator *iterator, uint16_t *value, uint16_t *index);

/**
 * @brief perform a blocking operation to read coils
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param output buffer that is written on success.
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The output buffer must be at least as large as count, otherwise a buffer overrun will occur
 */
Result read_coils(Session *session,
                  uint16_t start,
                  uint16_t count,
                  bool *output);

/**
 * @brief perform a non-blocking operation to read coils
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data providing context to the callback
 *
 * @note This function is thread-safe
 */
void read_coils_cb(Session *session,
                   uint16_t start,
                   uint16_t count,
                   void (*callback)(Result, const bool*, uint16_t, void*),
                   void *user_data);

/**
 * @brief perform a blocking operation to read discrete inputs
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param output buffer that is written on success.
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The output buffer must be at least as large as count, otherwise a buffer overrun will occur
 */
Result read_discrete_inputs(Session *session,
                            uint16_t start,
                            uint16_t count,
                            bool *output);

/**
 * @brief perform a non-blocking operation to read discrete inputs
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data providing context to the callback
 *
 * @note This function is thread-safe
 */
void read_discrete_inputs_cb(Session *session,
                             uint16_t start,
                             uint16_t count,
                             void (*callback)(Result, const bool*, uint16_t, void*),
                             void *user_data);

/**
 * @brief perform a blocking operation to read holding registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param output buffer that is written on success.
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The output buffer must be at least as large as count, otherwise a buffer overrun will occur
 */
Result read_holding_registers(Session *session,
                              uint16_t start,
                              uint16_t count,
                              uint16_t *output);

/**
 * @brief perform a non-blocking operation to read holding registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data providing context to the callback
 *
 * @note This function is thread-safe
 */
void read_holding_registers_cb(Session *session,
                               uint16_t start,
                               uint16_t count,
                               void (*callback)(Result, const uint16_t*, uint16_t, void*),
                               void *user_data);

/**
 * @brief perform a blocking operation to read input registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param output buffer that is written on success.
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The output buffer must be at least as large as count, otherwise a buffer overrun will occur
 */
Result read_input_registers(Session *session,
                            uint16_t start,
                            uint16_t count,
                            uint16_t *output);

/**
 * @brief perform a non-blocking operation to read input registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address for the operation
 * @param count count of items for the operation
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data providing context to the callback
 *
 * @note This function is thread-safe
 */
void read_input_registers_cb(Session *session,
                             uint16_t start,
                             uint16_t count,
                             void (*callback)(Result, const uint16_t*, uint16_t, void*),
                             void *user_data);

void release_updater(Updater *updater);

/**
 * @brief set the callback to invoke when an enabled level is logged
 *
 * @param callback Callback function to invoke
 *
 * @return true if the callback was successfully set
 * @warning this call will only succeed the first time it is made!
 */
bool set_log_callback(void (*callback)(Level level, const char *message));

/**
 * @brief set the maximum log level
 *
 * @param level maximum level at which messages will be logged
 */
void set_max_level(Level level);

bool update_coil(Updater *updater, bool value, uint16_t index);

void update_handler(Handler *handler, void *user_data, void (*callback)(Updater*, void*));

/**
 * @brief perform a blocking operation to write multiple coils
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address of the values
 * @param values array of values to write
 * @param count of values to write
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The "values" array must contain at least "count" items or the function will
 * read past the end of the buffer
 */
Result write_multiple_coils(Session *session, uint16_t start, const bool *values, uint16_t count);

/**
 * @brief perform a non-blocking operation to write multiple coils
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address of the values
 * @param values array of values to write
 * @param count count of values to write
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data data providing context to the callback
 *
 * @note This function is thread-safe
 * @warning "values" must contain at least "count" items or the function
 * will read past the end of the buffer
 */
void write_multiple_coils_cb(Session *session,
                             uint16_t start,
                             const bool *values,
                             uint16_t count,
                             void (*callback)(Result, void*),
                             void *user_data);

/**
 * @brief perform a blocking operation to write multiple registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address of the values
 * @param values array of values to write
 * @param count of values to write
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 * @warning The "values" array must contain at least "count" items or the function will
 * read past the end of the buffer
 */
Result write_multiple_registers(Session *session,
                                uint16_t start,
                                const uint16_t *values,
                                uint16_t count);

/**
 * @brief perform a non-blocking operation to write multiple registers
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param start starting address of the values
 * @param values array of values to write
 * @param count count of values to write
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data data providing context to the callback
 *
 * @note This function is thread-safe
 * @warning "values" must contain at least "count" items or the function
 * will read past the end of the buffer
 */
void write_multiple_registers_cb(Session *session,
                                 uint16_t start,
                                 const uint16_t *values,
                                 uint16_t count,
                                 void (*callback)(Result, void*),
                                 void *user_data);

/**
 * @brief perform a blocking operation to write a single coil
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param index address of the value
 * @param value value to write
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 */
Result write_single_coil(Session *session, uint16_t index, bool value);

/**
 * @brief perform a non-blocking operation to write a single coil
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param index address of the value
 * @param value value to write
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data data providing context to the callback
 *
 * @note This function is thread-safe
 */
void write_single_coil_cb(Session *session,
                          uint16_t index,
                          bool value,
                          void (*callback)(Result, void*),
                          void *user_data);

/**
 * @brief perform a blocking operation to write a single register
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param index address of the value
 * @param value value to write
 * @return #Result struct describing the success or failure of the operation
 *
 * @note This function is thread-safe
 */
Result write_single_register(Session *session, uint16_t index, uint16_t value);

/**
 * @brief perform a non-blocking operation to write a single register
 *
 * @param session pointer to the #Session struct that provides the runtime, channel, etc
 * @param index address of the value
 * @param value value to write
 * @param callback callback function to invoke when the operation completes
 * @param user_data pointer to optional user data data providing context to the callback
 *
 * @note This function is thread-safe
 */
void write_single_register_cb(Session *session,
                              uint16_t index,
                              uint16_t value,
                              void (*callback)(Result, void*),
                              void *user_data);

#endif /* RODBUS_FFI_H */
